"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_emoji_1 = __importDefault(require("node-emoji"));
const manageMetadata_1 = require("./manageMetadata");
const checkPermission_1 = require("./util/checkPermission");
const throwError_1 = require("./util/throwError");
class DynamicMessage {
    constructor(config = { volatile: true }) {
        this.isResponse = false;
        this.responseTo = null;
        this.__message = null;
        /*
        Apparently discord has some problems with certain emoji
        ex: :one: needs to be sent in and escaped unicode format: \u0030\u20E3
      
        See:
          - https://stackoverflow.com/questions/49225971/discord-js-message-react-fails-when-adding-specific-unicode-emotes
          - https://github.com/discordjs/discord.js/issues/2287
        */
        this.emojiFixes = {
            ':zero:': '\u0030\u20E3',
            ':one:': '\u0031\u20E3',
            ':two:': '\u0032\u20E3',
            ':three:': '\u0033\u20E3',
            ':four:': '\u0034\u20E3',
            ':five:': '\u0035\u20E3',
            ':six:': '\u0036\u20E3',
            ':seven:': '\u0037\u20E3',
            ':eight:': '\u0038\u20E3',
            ':nine:': '\u0039\u20E3',
        };
        this.setupReactionCollector = () => __awaiter(this, void 0, void 0, function* () {
            try {
                // Setup known "none-hidden" reactions on the message
                yield this.addReactions(Object.keys(this.metadata.reactionHandlers)
                    .filter((emojiCode) => !this.metadata.reactionHandlers[emojiCode].config.hidden)
                    .sort((a, b) => this.metadata.reactionHandlers[a].registrationOrder - this.metadata.reactionHandlers[b].registrationOrder));
                // Setup reaction collector for known emoji
                this.reactionCollector = this.message.createReactionCollector(() => true);
                this.message.client.on('messageReactionRemove', this.handleReactionRemoved);
                // Setup reaction handler for new reactions
                this.reactionCollector.on('collect', (reaction) => this.handleReaction(reaction, false));
                // Retroactively handle reaction already on the message
                this.message.reactions.cache.forEach((reaction) => this.handleReaction(reaction, true));
            }
            catch (err) {
                throwError_1.throwError(this.config, String(err));
            }
        });
        this.config = config;
        this.handleReactionRemoved = this.handleReactionRemoved.bind(this);
        // Pull in metadata config defined in decorators
        this.metadata = manageMetadata_1.metadata.get(this);
    }
    set message(newMessage) {
        if (this.__message !== null) {
            this.tearDownReactionCollector();
        }
        if (newMessage === null) {
            this.__message = null;
            return;
        }
        checkPermission_1.checkPermissions(this.config, newMessage.guild);
        this.__message = newMessage;
        this.setupReactionCollector();
        // Call init handler
        if (this.metadata.initHandler) {
            this[this.metadata.initHandler.handlerKey]();
        }
    }
    get message() {
        return this.__message;
    }
    sendTo(channel) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.message = (yield channel.send(this.render()));
            }
            catch (err) {
                throwError_1.throwError(this.config, String(err));
            }
            return this;
        });
    }
    replyTo(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.message = (yield msg.reply(this.render()));
                this.isResponse = true;
                this.responseTo = msg.author;
            }
            catch (err) {
                throwError_1.throwError(this.config, String(err));
            }
            return this;
        });
    }
    attachTo(message, responseTo) {
        try {
            this.message = message;
            if (responseTo) {
                this.isResponse = true;
                this.responseTo = responseTo;
            }
        }
        catch (err) {
            throwError_1.throwError(this.config, String(err));
        }
        this.reRender();
        return this;
    }
    reRender() {
        if (this.isResponse) {
            this.message.edit(`${this.responseTo} ${this.render()}`)
                .catch((err) => throwError_1.throwError(this.config, String(err)));
        }
        else {
            this.message.edit(this.render())
                .catch((err) => throwError_1.throwError(this.config, String(err)));
        }
    }
    addReactions(emojiNames) {
        return __awaiter(this, void 0, void 0, function* () {
            return emojiNames
                .map((emojiCode) => emojiCode in this.emojiFixes ?
                this.emojiFixes[emojiCode] : node_emoji_1.default.get(emojiCode))
                .reduce((promise, emoji) => promise.then(() => this.message.react(emoji)), Promise.resolve());
        });
    }
    tearDownReactionCollector() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.message.reactions.removeAll();
                this.reactionCollector.removeAllListeners();
                this.message.client.off('messageReactionRemove', this.handleReactionRemoved);
            }
            catch (err) {
                throwError_1.throwError(this.config, String(err));
            }
        });
    }
    handleReactionRemoved(reaction, user) {
        const filter = ({ ignoreBots, ignoreHumans }) => {
            if (user.bot) {
                return !ignoreBots;
            }
            else {
                return !ignoreHumans;
            }
        };
        try {
            if (reaction.message.id !== this.message.id) {
                // Not this message
                return;
            }
            if (this.metadata.catchAllReactionRemovedHandler) {
                const { handlerKey: catchAllHandlerKey, config, } = this.metadata.catchAllReactionRemovedHandler;
                if (!filter(config)) {
                    return;
                }
                this[catchAllHandlerKey](user, this.message.channel, reaction);
                if (config.triggerRender) {
                    this.reRender();
                }
            }
            const emojiCode = node_emoji_1.default.unemojify(reaction.emoji.name);
            if (!(emojiCode in this.metadata.reactionRemovedHandlers)) {
                // No registered handler
                return;
            }
            const { handlerKey, config: { ignoreBots, ignoreHumans, triggerRender, }, } = this.metadata.reactionRemovedHandlers[emojiCode];
            if (!filter({ ignoreBots, ignoreHumans })) {
                return;
            }
            this[handlerKey](user, this.message.channel, reaction);
            if (triggerRender) {
                this.reRender();
            }
        }
        catch (err) {
            throwError_1.throwError(this.config, String(err));
        }
    }
    handleReaction(reaction, isRetroactive) {
        return __awaiter(this, void 0, void 0, function* () {
            const filter = (user, { ignoreBots, ignoreHumans }) => {
                if (user.bot) {
                    return !ignoreBots;
                }
                else {
                    return !ignoreHumans;
                }
            };
            try {
                if (this.metadata.catchAllReactionHandler) {
                    const { handlerKey: catchAllHandlerKey, config, } = this.metadata.catchAllReactionHandler;
                    (yield reaction.users.fetch())
                        .filter((user) => filter(user, config))
                        .forEach((user) => {
                        this[catchAllHandlerKey](user, this.message.channel, reaction);
                    });
                    if (config.triggerRender) {
                        this.reRender();
                    }
                }
                if (!(node_emoji_1.default.unemojify(reaction.emoji.name) in this.metadata.reactionHandlers)) {
                    return;
                }
                const emojiCode = node_emoji_1.default.unemojify(reaction.emoji.name);
                const { handlerKey, config: { removeWhenDone, ignoreBots, ignoreHumans, doRetroactiveCallback, triggerRender, }, } = this.metadata.reactionHandlers[emojiCode];
                if (isRetroactive && !doRetroactiveCallback) {
                    // No retroactive callback should be applied
                    return;
                }
                // fetchUsers is needed for retroactive callback application
                const users = yield reaction.users.fetch();
                users.filter((user) => filter(user, { ignoreBots, ignoreHumans }))
                    .forEach((user) => {
                    this[handlerKey](user, this.message.channel, reaction);
                    if (removeWhenDone) {
                        reaction.users.remove(user);
                    }
                });
                if (triggerRender) {
                    this.reRender();
                }
            }
            catch (err) {
                throwError_1.throwError(this.config, String(err));
            }
        });
    }
}
exports.DynamicMessage = DynamicMessage;
